#!/usr/bin/env python3
"""Render the 80-model notebook catalog into README and docs."""
from __future__ import annotations

import csv
import shutil
from collections import defaultdict
from pathlib import Path
from typing import Dict, List

ROOT = Path(__file__).resolve().parents[1]
CATALOG_CSV = ROOT / "meta" / "notebook_catalog.csv"
README = ROOT / "README.md"
CATALOG_OVERVIEW = ROOT / "notebooks" / "catalog.md"

EXPECTED_HEADERS = [
    "section",
    "model_id",
    "model_name",
    "use_case",
    "library_deps",
    "hardware_profile",
    "ram_usage_estimate",
    "notes",
    "notebook_path",
    "colab_link",
    "status",
]
SECTIONS_ORDER = ["audio", "multimodal", "nlp", "vision"]
SECTION_LABELS = {
    "audio": "Audio",
    "multimodal": "Multimodal",
    "nlp": "NLP",
    "vision": "Vision",
}
SECTION_DIRS = {sec: ROOT / "notebooks" / sec for sec in SECTIONS_ORDER}
OLD_DOCS_OVERVIEW = ROOT / "docs" / "catalog.md"
OLD_DOCS_SECTION_DIR = ROOT / "docs" / "catalog"
OLD_DOCS_SECTION_SUBDIRS = [ROOT / "docs" / sec for sec in SECTIONS_ORDER]
MARKER_START = "<!-- CATALOG:START -->"
MARKER_NOTE = "<!-- generated by /scripts/build_catalog.py ; do not edit manually -->"
MARKER_END = "<!-- CATALOG:END -->"


def load_catalog() -> List[Dict[str, str]]:
    if not CATALOG_CSV.exists():
        raise SystemExit(f"Catalog CSV not found: {CATALOG_CSV}")

    with CATALOG_CSV.open("r", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        headers = reader.fieldnames
        if headers != EXPECTED_HEADERS:
            raise SystemExit(
                "notebook_catalog.csv headers mismatch.\n"
                f"Expected: {EXPECTED_HEADERS}\n"
                f"Found:    {headers}"
            )
        rows = [row for row in reader]

    if len(rows) < 80:
        raise SystemExit(f"Catalog must contain at least 80 rows; found {len(rows)}")

    by_section = defaultdict(int)
    for row in rows:
        section = row["section"].strip().lower()
        if section not in SECTIONS_ORDER:
            raise SystemExit(f"Unknown section '{row['section']}' in catalog.")
        by_section[section] += 1

    for section in SECTIONS_ORDER:
        if by_section[section] == 0:
            raise SystemExit(f"Section '{section}' has no entries.")

    return rows


def condensed_table(rows: List[Dict[str, str]]) -> str:
    selected: Dict[str, List[Dict[str, str]]] = {sec: [] for sec in SECTIONS_ORDER}
    for row in rows:
        sec = row["section"].strip().lower()
        if sec in selected and len(selected[sec]) < 4:
            selected[sec].append(row)

    for sec in SECTIONS_ORDER:
        if len(selected[sec]) < 4:
            raise SystemExit(f"Section '{sec}' needs at least 4 entries for condensed table.")

    header = "| Notebook | Use case | Deps | Hardware | RAM |\n|---|---|---|---|---|"
    lines = [header]

    for sec in SECTIONS_ORDER:
        for row in selected[sec]:
            model_link = f"https://huggingface.co/{row['model_id']}"
            tag = sec.upper()
            notebook_cell = f"**{tag}** · [{row['model_name']}]({model_link})"
            use_case = row["use_case"].strip()
            deps = ", ".join(part.strip() for part in row["library_deps"].split(","))
            hardware = row["hardware_profile"].strip()
            ram = row["ram_usage_estimate"].strip()
            lines.append(f"| {notebook_cell} | {use_case} | {deps} | {hardware} | {ram} |")

    lines.append("")
    lines.append("[View the full 80-model catalog →](./notebooks/catalog.md)")
    return "\n".join(lines)


def build_section_pages(rows: List[Dict[str, str]]) -> Dict[str, str]:
    pages: Dict[str, str] = {}
    for sec in SECTIONS_ORDER:
        section_rows = [row for row in rows if row["section"].strip().lower() == sec]
        title = SECTION_LABELS.get(sec, sec.capitalize())
        lines: List[str] = [f"# {title} Notebook Catalog", ""]
        lines.append("| Model | Use case | Deps | Hardware | RAM | Notes | Notebook |")
        lines.append("|---|---|---|---|---|---|---|")
        for row in section_rows:
            model_link = f"https://huggingface.co/{row['model_id']}"
            model_cell = (
                f"[{row['model_name']}]({model_link})"
                f"<br><sub>{row['model_id']}</sub>"
            )
            use_case = row["use_case"].strip()
            deps = ", ".join(part.strip() for part in row["library_deps"].split(","))
            hardware = row["hardware_profile"].strip()
            ram = row["ram_usage_estimate"].strip()
            notes = row["notes"].strip() or "—"
            notebook_path = row["notebook_path"].strip()
            notebook_cell = notebook_path if notebook_path and notebook_path != "TODO" else "—"
            lines.append(
                f"| {model_cell} | {use_case} | {deps} | {hardware} | {ram} | {notes} | {notebook_cell} |"
            )
        lines.append("")
        lines.append("_Source of truth: `/meta/notebook_catalog.csv`._")
        lines.append("")
        pages[sec] = "\n".join(lines)
    return pages


def update_readme(table_markdown: str) -> None:
    text = README.read_text(encoding="utf-8")
    start = text.find(MARKER_START)
    end = text.find(MARKER_END)
    if start == -1 or end == -1:
        raise SystemExit("Catalog markers not found in README.md")
    end += len(MARKER_END)
    block = f"{MARKER_START}\n{MARKER_NOTE}\n{table_markdown}\n{MARKER_END}"
    updated = text[:start] + block + text[end:]
    README.write_text(updated, encoding="utf-8")


def main() -> None:
    rows = load_catalog()
    table_md = condensed_table(rows)
    section_pages = build_section_pages(rows)
    update_readme(table_md)
    if OLD_DOCS_SECTION_DIR.exists():
        shutil.rmtree(OLD_DOCS_SECTION_DIR)
    for old_dir in OLD_DOCS_SECTION_SUBDIRS:
        if old_dir.exists():
            shutil.rmtree(old_dir)
    if OLD_DOCS_OVERVIEW.exists():
        OLD_DOCS_OVERVIEW.unlink()

    index_lines = [
        "# Notebook Catalog Overview",
        "",
        "Browse per-domain model picks ready for notebook implementation:",
        "",
    ]
    for sec in SECTIONS_ORDER:
        index_lines.append(f"- [{SECTION_LABELS.get(sec, sec.capitalize())}](./{sec}/{sec}_catalog.md)")
    index_lines.extend(
        [
            "",
            "_Source of truth: `/meta/notebook_catalog.csv`._",
            "",
        ]
    )
    CATALOG_OVERVIEW.parent.mkdir(parents=True, exist_ok=True)
    CATALOG_OVERVIEW.write_text("\n".join(index_lines), encoding="utf-8")

    for sec, content in section_pages.items():
        target_dir = SECTION_DIRS[sec]
        target_dir.mkdir(parents=True, exist_ok=True)
        target = target_dir / f"{sec}_catalog.md"
        target.write_text(content, encoding="utf-8")

    print("Catalog build complete.")


if __name__ == "__main__":
    main()
